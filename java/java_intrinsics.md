# Java Intrinsics

Так как JVM является интерпретатором, то выполнять приходится каждую команду последовательно. Некоторые команды реализуются на аппаратном уровне процессором.  Конкретный интерпретатор (Linux, OSX, …) знает о рабочем окружении (процессор, память) и совершает подмену определенных команд на аппаратные команды.
Работает это следующим способом, есть функция в Java **Integer.bitCount()**:
```
   public static int bitCount(int i) {
      i = i - ((i >>> 1) & 0x55555555);
      i = (i & 0x33333333) + ((i >>> 2) & 0x33333333);
      i = (i + (i >>> 4)) & 0x0f0f0f0f;
      i = i + (i >>> 8);
      i = i + (i >>> 16);
      return i & 0x3f;
    }    
```
есть аппаратная функция **popcnt** для X86 процессора, которая делает то же самое но за один такт. JIT выполняет на X86 процессоре подмену этой функции на popcnt, тем самым увеличивая производительность. 

Под капотом находится мапа соответствий, для какого метода какая аппаратная команда. Т.е. если скопировать содержимое этой функции к себе в проект, то JIT не выполнит подмену так как работает только с внутренним кодом JVM.  Соответствие какому процессору какие команды описываются как **Java intrinsics**

```
if (funcName == "Integer.bitCount"  && CPU == x86)
  useIntrinsic()
else
  useNormalFunc()
```

Описано [тут] (http://vanillajava.blogspot.com/2012/11/java-intrinsics-and-performance.html)
Взято из [переписки] (https://github.com/Hexlet/hexlet-slack-archive/wiki/JIT-компиляторы.-JIT-в-JVM)
